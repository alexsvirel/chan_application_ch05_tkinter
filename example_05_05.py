#!/usr/bin/env python
"""
Приnожение, в котором применяется механизм PFA

С помощью механизма PFA можно кешировать параметры функции, фактически фиксируя
их как заранее заданные аргументы, а затем, во время выполнения программы, получив
остальные необходимые параметры, извлечь из кэша зафиксированные аргументы,
добавить их в список и вызвать функцию со всеми параметрами.
"""
# Работа приложения начинается с импорта метода functools.partial() , задания
# нескольких атрибугов Tkinter и построения диалоrовых окон Tk (строки 12 - 14).
from functools import partial as pto
from tkinter import Button, Tk, X
from tkinter.messagebox import showinfo, showwarning, showerror
# Затем определяются требуемые знаки с указанием их категории (строки 16 - 27).
CRIT = "crit"
WARN = "warn"
REGU = "regu"

SIGNS = {
    "do not enter": CRIT,
    "railroad crossing": WARN,
    "55\nspeed limit": REGU,
    "merging traffic": WARN,
    "wrong way": CRIT,
    "one way": REGU,
}
# Устанавливается связь между диалоrовыми окнами Tk и функциями обратноrо
# вызова кнопок, которые используются для каждой созданной кнопки (строки 30 - 32).
critCB = lambda: showerror("Error", "Error Button Pressed!")
warnCB = lambda: showwarning("Warning", "Warning Button Pressed!")
reguCB = lambda: showinfo("Info", "Info Button Pressed")
# Затем происходит запуск среды Tk, задается название и создается кнопка QUIТ (строки 34 - 36).
top = Tk()
top.title("Road Signs")
Button(top, text="QUIT", command=top.quit, bg="red", fg="white").pack()
# (Строки 54 - 57) В этих строках заключается вся маrия используемоrо механизма PFA.
# Применяются два уровня PFA. На первом уровне формируются ·шаблон класса Button и
# корневое окно top. Это означает, что при каждом вызове в проrрамме объекта MyButton
# этот объект вызывает Button (метод Tkinter . Button ( ) создает кнопку) с указанием
# top в качестве первоrо параметра. Эти действия предусмотрены в объекте MyButton.
# На втором уровне использования механизма PFA применяется первый созданный
# объект, MyButton, и на ero основе создаются шаблоны. Для знаков каждой катеrории
# формируются отдельные типы кнопок. При создании пользователем запрещающей
# кнопки CritButton (путем вызова ее, например, в форме CritButton ( ) ) следующим
# действием становится вызов MyButton, сопровождаемый определением необходимой
# функции обратноrо вызова кнопки и цветов фона и переднеrо плана. Иными словами,
# происходит вызов Button с указанием параметра top, функции обратноrо вызова
# и цветов. После этого можно наблюдать за тем, как происходит развертывание
# и переход вниз по уровням вплоть до каждой кнопки, в которой уже предусмотрен
# необходимый вызов. Если бы не возможности механизма PFA, то проrраммисту пришлось
# бы задавать такой обратный вызов с нуля. Аналоrичным образом создаются
# кнопки WarnButton и ReguButton.
MyButton = pto(Button, top)
CritButton = pto(MyButton, command=critCB, bg="white", fg="red")
WarnButton = pto(MyButton, command=warnCB, bg="goldenrod1")
ReguButton = pto(MyButton, command=reguCB, bg="white")
# (Строки 68 -72) После завершения этой подготовительной работы рассматривается список
# знаков и происходит их создание. Формируется строка, которую может вычислить
# интерпретатор Python, включающая имя создаваемой кнопки, в
# качестве текстового параметра передается метка на кнопке, затем к параметрам
# применяется метод pack ( ) . Если формируемый знак является запрещающим,
# то буквы метки на кнопке преобразуются в прописные, в противном
# случае в прописную преобразуются первые буквы каждого слова в метке.
# Последняя интересная особенность обнаруживается в строке 72, где
# демонстрируется трехместный условный оператор.
# Порождение экземпляра каждой кнопки осуществляется с помощью метода eval ( )
for each_sign in SIGNS:
    sign_type = SIGNS[each_sign]
    cmd = "%sButton(text=%r%s).pack(fill=X, expand=True)" % (sign_type.title(), each_sign,
          '.upper()' if sign_type == CRIT else '.title()')
    eval(cmd)
top.mainloop()
